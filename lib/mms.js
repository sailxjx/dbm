// Generated by CoffeeScript 1.7.1
(function() {
  var MMS, async, colors, config, exec, fs, mkdirp, path, util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  util = require('util');

  mkdirp = require('mkdirp');

  colors = require('colors');

  async = require('async');

  exec = require('child_process').exec;

  config = require('./config');

  MMS = (function() {
    function MMS() {
      this._loadrc();
    }

    MMS.prototype._loadrc = function() {
      var e;
      try {
        return config = util._extend(config, require(path.resolve('./.mmsrc.json')));
      } catch (_error) {
        e = _error;
      }
    };

    MMS.prototype._loadMigrations = function() {
      var files, migrations;
      migrations = {};
      files = fs.readdirSync(config.dir);
      files = files.filter(function(file) {
        if (file.match(/^[0-9]{13}_(up|down)_.*\.(js|coffee)$/)) {
          return true;
        } else {
          return false;
        }
      });
      files.sort(function(x, y) {
        return Number(x.split('_')[0]) - Number(y.split('_')[0]);
      });
      files.forEach(function(file) {
        var downFile, title, upFile;
        title = file.replace(/^[0-9]{13}_(up|down)/, function(code) {
          return code.split('_')[0];
        });
        upFile = title.replace(/^[0-9]{13}/, function(code) {
          return code + '_up';
        });
        downFile = title.replace(/^[0-9]{13}/, function(code) {
          return code + '_down';
        });
        title = title.split('.')[0];
        if (__indexOf.call(files, upFile) >= 0 && __indexOf.call(files, downFile) >= 0) {
          return migrations[title] = {
            up: upFile,
            down: downFile
          };
        } else {
          return delete migrations[title];
        }
      });
      return migrations;
    };

    MMS.prototype._checkVersion = function(name, migrations) {
      var migration, nameIdx, title, versionIdx;
      if (name == null) {
        return true;
      }
      versionIdx = {};
      nameIdx = {};
      for (title in migrations) {
        migration = migrations[title];
        versionIdx[title.slice(0, 13)] = 1;
        nameIdx[title.slice(14)] = 1;
      }
      if (!(versionIdx[name] || nameIdx[name] || (name != null ? name.match(/[0-9]{1,5}/) : void 0))) {
        console.error('  fail'.red, ("migration [" + name + "] not found!").grey);
        return process.exit(1);
      }
    };

    MMS.prototype._migrate = function(file, callback) {
      var isCoffee;
      if (callback == null) {
        callback = function() {};
      }
      if (path.extname(file) === '.coffee') {
        isCoffee = true;
      }
      return async.waterfall([
        function(next) {
          var filePath;
          filePath = path.join(config.dir, file);
          if (isCoffee) {
            return exec("coffee -c " + filePath, function(err) {
              filePath = filePath.replace('.coffee', '.js');
              return next(err, filePath);
            });
          } else {
            return next(null, filePath);
          }
        }, function(filePath, next) {
          var child;
          child = exec("mongo " + config.db + " --quiet " + filePath, function(err) {
            return next(err, filePath);
          });
          child.stdout.on('data', function(data) {
            return process.stdout.write(data);
          });
          return child.stderr.on('data', function(data) {
            return process.stderr.write(data);
          });
        }, function(filePath, next) {
          if (isCoffee) {
            fs.unlinkSync(filePath);
          }
          return next();
        }
      ], function(err) {
        if (err != null) {
          console.error('  fail'.red, file.grey);
          return process.exit(2);
        } else {
          console.log('  succ'.green, file.grey);
          return callback();
        }
      });
    };

    MMS.prototype.create = function(name, options, callback) {
      var downFile, ext, timestamp, upFile;
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function() {};
      }
      timestamp = Date.now();
      ext = config.ext || '.js';
      upFile = path.join(config.dir, "" + timestamp + "_up_" + name + ext);
      downFile = path.join(config.dir, "" + timestamp + "_down_" + name + ext);
      mkdirp.sync(config.dir);
      fs.writeFileSync(upFile, '');
      console.log('  create'.cyan, upFile.grey);
      fs.writeFileSync(downFile, '');
      console.log('  create'.cyan, downFile.grey);
      return callback();
    };

    MMS.prototype.migrate = function(name, options, callback) {
      var e, migrations, newSchema, schema, step;
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function() {};
      }
      migrations = this._loadMigrations();
      this._checkVersion(name, migrations);
      try {
        schema = require(path.resolve(config.schema));
      } catch (_error) {
        e = _error;
        schema = {};
      }
      newSchema = {};
      step = 0;
      return async.eachSeries(Object.keys(migrations), (function(_this) {
        return function(title, next) {
          var migration;
          if ((schema[title] != null) && schema[title].status === 'up') {
            newSchema[title] = {
              status: 'up'
            };
            return next();
          } else {
            migration = migrations[title];
            console.log('  migrate'.cyan, title.grey);
            return _this._migrate(migration.up, function() {
              step += 1;
              newSchema[title] = {
                status: 'up'
              };
              fs.writeFileSync(config.schema, JSON.stringify(newSchema, null, 2));
              if (name == null) {
                return next();
              }
              if (name.match(/[0-9]{1,5}/ && step === Number(name))) {
                return next('finish');
              }
              if (title.indexOf(name) > -1) {
                return next('finish');
              }
              return next();
            });
          }
        };
      })(this), function(err) {
        console.log('  complete'.cyan);
        return callback();
      });
    };

    MMS.prototype.rollback = function(name, options, callback) {
      var e, migrations, schema, step, titles;
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function() {};
      }
      migrations = this._loadMigrations();
      this._checkVersion(name, migrations);
      try {
        schema = require(path.resolve(config.schema));
      } catch (_error) {
        e = _error;
        schema = {};
      }
      step = 0;
      titles = Object.keys(schema);
      titles.sort(function(x, y) {
        return 1;
      });
      return async.eachSeries(titles, (function(_this) {
        return function(title, next) {
          var migration;
          step += 1;
          migration = migrations[title];
          if (migration == null) {
            delete schema[title];
            return next();
          }
          console.log('  rollback'.cyan, title.grey);
          return _this._migrate(migration.down, function() {
            delete schema[title];
            fs.writeFileSync(config.schema, JSON.stringify(schema, null, 2));
            if (name == null) {
              return next();
            }
            if (name.match(/[0-9]{1,5}/ && step === Number(name))) {
              return next('finish');
            }
            if (title.indexOf(name) > -1) {
              return next('finish');
            }
            return next();
          });
        };
      })(this), function(err) {
        console.log('  complete'.cyan);
        return callback();
      });
    };

    MMS.prototype.status = function(callback) {
      var e, migration, migrations, schema, status, title, _ref;
      if (callback == null) {
        callback = function() {};
      }
      migrations = this._loadMigrations();
      try {
        schema = require(path.resolve(config.schema));
      } catch (_error) {
        e = _error;
        schema = {};
      }
      status = {};
      console.log('  status'.cyan);
      for (title in migrations) {
        migration = migrations[title];
        if (((_ref = schema[title]) != null ? _ref.status : void 0) === 'up') {
          status[title] = 'up';
          console.log("  up".green, title.grey);
        } else {
          status[title] = 'down';
          console.log("  down".red, title.grey);
        }
      }
      return callback(null, status);
    };

    return MMS;

  })();

  module.exports = new MMS;

}).call(this);
